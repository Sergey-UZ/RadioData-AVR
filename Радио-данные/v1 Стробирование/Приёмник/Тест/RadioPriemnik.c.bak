/*******************************************************
This program was created by the CodeWizardAVR V3.40 
Automatic Program Generator
© Copyright 1998-2020 Pavel Haiduc, HP InfoTech S.R.L.
http://www.hpinfotech.ro

Project : Радио-приёмник
Version : 1
Date    : 12.10.2023
Author  : Sergey
Company : 
Comments: 
          Микроконтроллер тактируется от
          кварцевого генератора частотой 4 МГц.
          Входной сигнал на любой PIN.
          Манчестерское кодирование.
          Входной бит данных 1 --- передаётся как сначало 1 потом 0
          Входной бит данных 0 --- передаётся как сначало 0 потом 1

Chip type               : ATtiny2313A
AVR Core Clock frequency: 4,000000 MHz
Memory model            : Tiny
External RAM size       : 0
Data Stack size         : 32
*******************************************************/

#include <tiny2313a.h>

#define RADIO_SIGNAL_IN PIND.3  //Ножка к которой подключён радио-приёмник 
flash unsigned char PREAMBULA = 0b01010101; // Преамбула передатчика

// Флаг устанавливается в 1 - каждый периуд стробирования
char StrobPeriudFlag = 0;
volatile unsigned int msLedB = 0; // Переменная для подсчёта миллисекунд для LED Blue




// Прототипы функций ===============================
void RadioPriem(void);
interrupt [TIM1_COMPA] void timer1_compa_isr(void);
void main(void);
//==================================================



// Радио-приём данных
void RadioPriem(void)
{
	// Информационный бит и все его состояния
	static enum InfoBit
	{
		_0 = 0, // Бит 0
		_1 = 1, // Бит 1
		A_ = 2, // Полубит А
		//_B = 3, // Полубит В
	  Neopredelen = 4, // Неопределённое
	} InfoBit = Neopredelen;
	// Поиск пакета и все его состояния
	static enum Paket
	{
		Bit0 = 0, // Бит 0 (всегда = лог 1)
		Bit1_7 = 1, // Бит с 1-го по 7-ой (вместе с бит 0 содержит преамбулу)
		Bit8_n = 2, // Бит с 8-го по n-ый (данные пользователя + CRC)
	} Paket = Bit0;
	
	// Счётчик логических 1 принятого сигнала в каждом полубите информационного бита
	static unsigned char PoluBitStrobCount = 0; // Кол-во прошедшых стробирующих периудов
	static unsigned char PoluBit_A_Count1 = 0; // Кол-во принятых 1-ных сигналов полубита A
	static unsigned char PoluBit_B_Count1 = 0; // Кол-во принятых 1-ных сигналов полубита B
	 
	
	// Test
  PORTD.4 = ~PORTD.4; // 3 0,125 мс
  
  // Поиск информационного бита
  switch (InfoBit)
  {
  case Neopredelen:
    if (RADIO_SIGNAL_IN == 1)
    	++PoluBit_A_Count1;
    ++PoluBitStrobCount;	    
  	break;
  case A_:
    if (RADIO_SIGNAL_IN == 1)
    	++PoluBit_B_Count1;
    ++PoluBitStrobCount;	    
  	break;
  }
  // Полубит из входного сигнала найден
  if (PoluBitStrobCount == 8)
  {
  	PoluBitStrobCount = 0;
  	switch (InfoBit)
  	{
  	case Neopredelen:
  	  InfoBit = A_; 
  		break;
  	case A_:
  		if (PoluBit_A_Count1 > PoluBit_B_Count1)
  			InfoBit = _1;
  		if (PoluBit_A_Count1 < PoluBit_B_Count1)
  			InfoBit = _0;
  		// Перезагрузка радио-приёма	
  		if (PoluBit_A_Count1 == PoluBit_B_Count1)
  		{
  			PoluBit_A_Count1 = 0;
  			PoluBit_B_Count1 = 0;
  			InfoBit = Neopredelen;		
  			Paket = Bit0;
  			return;
  		}
  		PoluBit_A_Count1 = 0;
  		PoluBit_B_Count1 = 0;  		
  		break;  			
  	}  		  		
  }			
  switch (Paket)
  {
  case Bit0:
  	// Перезагрузка радио-приёма
    if (InfoBit == _0)
    {
    	InfoBit = Neopredelen;
    	return;
    }
    // Нулевой бит преамбулы найден
    if (InfoBit == _1)
    {
    	// Test
	    PORTD.5 = ~PORTD.5; // 4 Сигнал 1
	    
	    msLedB = 1200;    
		  PORTB.3 = 1; // Включить LED B
	    InfoBit = Neopredelen;
	    return;
    }	
  	break;
  		
  }
}


// Timer1 output compare A interrupt service routine
// Прерывание каждые 0,125 ms
interrupt [TIM1_COMPA] void timer1_compa_isr(void)
{
	StrobPeriudFlag = 1;
	// Всегда уменьшать переменную до нуля
  if (msLedB != 0)
    --msLedB;
}


void main(void)
{
	// Crystal Oscillator division factor: 1
	#pragma optsize-
		CLKPR=(1<<CLKPCE);
		CLKPR=(0<<CLKPCE) | (0<<CLKPS3) | (0<<CLKPS2) | (0<<CLKPS1) | (0<<CLKPS0);
	#ifdef _OPTIMIZE_SIZE_
	#pragma optsize+
	#endif

	// Input/Output Ports initialization
	// Port A initialization
	// Function: Bit2=In Bit1=In Bit0=In 
	DDRA=(0<<DDA2) | (0<<DDA1) | (0<<DDA0);
	// State: Bit2=T Bit1=T Bit0=T 
	PORTA=(0<<PORTA2) | (0<<PORTA1) | (0<<PORTA0);

	// Port B initialization
	// Function: Bit7=Out Bit6=Out Bit5=Out Bit4=In Bit3=Out Bit2=Out Bit1=Out Bit0=Out 
	DDRB=(1<<DDB7) | (1<<DDB6) | (1<<DDB5) | (0<<DDB4) | (1<<DDB3) | (1<<DDB2) | (1<<DDB1) | (1<<DDB0);
	// State: Bit7=0 Bit6=0 Bit5=0 Bit4=P Bit3=0 Bit2=0 Bit1=0 Bit0=0 
	PORTB=(0<<PORTB7) | (0<<PORTB6) | (0<<PORTB5) | (1<<PORTB4) | (0<<PORTB3) | (0<<PORTB2) | (0<<PORTB1) | (0<<PORTB0);

	// Port D initialization
	// Function: Bit6=Out Bit5=Out Bit4=Out Bit3=In Bit2=In Bit1=Out Bit0=Out 
	DDRD=(1<<DDD6) | (1<<DDD5) | (1<<DDD4) | (0<<DDD3) | (0<<DDD2) | (1<<DDD1) | (1<<DDD0);
	// State: Bit6=0 Bit5=0 Bit4=0 Bit3=T Bit2=T Bit1=0 Bit0=0 
	PORTD=(0<<PORTD6) | (0<<PORTD5) | (0<<PORTD4) | (0<<PORTD3) | (0<<PORTD2) | (0<<PORTD1) | (0<<PORTD0);

	// Timer/Counter 0 initialization
	// Clock source: System Clock
	// Clock value: Timer 0 Stopped
	// Mode: Normal top=0xFF
	// OC0A output: Disconnected
	// OC0B output: Disconnected
	TCCR0A=(0<<COM0A1) | (0<<COM0A0) | (0<<COM0B1) | (0<<COM0B0) | (0<<WGM01) | (0<<WGM00);
	TCCR0B=(0<<WGM02) | (0<<CS02) | (0<<CS01) | (0<<CS00);
	TCNT0=0x00;
	OCR0A=0x00;
	OCR0B=0x00;

	// Timer/Counter 1 initialization
	// Clock source: System Clock
	// Clock value: 4000,000 kHz
	// Mode: CTC top=OCR1A
	// OC1A output: Disconnected
	// OC1B output: Disconnected
	// Noise Canceler: Off
	// Input Capture on Falling Edge
	// Timer Period: 0,125 ms
	// Timer1 Overflow Interrupt: Off
	// Input Capture Interrupt: Off
	// Compare A Match Interrupt: On
	// Compare B Match Interrupt: Off
	TCCR1A=(0<<COM1A1) | (0<<COM1A0) | (0<<COM1B1) | (0<<COM1B0) | (0<<WGM11) | (0<<WGM10);
	TCCR1B=(0<<ICNC1) | (0<<ICES1) | (0<<WGM13) | (1<<WGM12) | (0<<CS12) | (0<<CS11) | (1<<CS10);
	TCNT1H=0x00;
	TCNT1L=0x00;
	ICR1H=0x00;
	ICR1L=0x00;
	OCR1AH=0x01;
	OCR1AL=0xF3;
	OCR1BH=0x00;
	OCR1BL=0x00;

	// Timer(s)/Counter(s) Interrupt(s) initialization
	TIMSK=(0<<TOIE1) | (1<<OCIE1A) | (0<<OCIE1B) | (0<<ICIE1) | (0<<OCIE0B) | (0<<TOIE0) | (0<<OCIE0A);

	// External Interrupt(s) initialization
	// INT0: Off
	// INT1: Off
	// Interrupt on any change on pins PCINT0-7: Off
	// Interrupt on any change on pins PCINT8-10: Off
	// Interrupt on any change on pins PCINT11-17: Off
	MCUCR=(0<<ISC11) | (0<<ISC10) | (0<<ISC01) | (0<<ISC00);
	GIMSK=(0<<INT1) | (0<<INT0) | (0<<PCIE0) | (0<<PCIE2) | (0<<PCIE1);

	// USI initialization
	// Mode: Disabled
	// Clock source: Register & Counter=no clk.
	// USI Counter Overflow Interrupt: Off
	USICR=(0<<USISIE) | (0<<USIOIE) | (0<<USIWM1) | (0<<USIWM0) | (0<<USICS1) | (0<<USICS0) | (0<<USICLK) | (0<<USITC);

	// USART initialization
	// USART disabled
	UCSRB=(0<<RXCIE) | (0<<TXCIE) | (0<<UDRIE) | (0<<RXEN) | (0<<TXEN) | (0<<UCSZ2) | (0<<RXB8) | (0<<TXB8);

	// Analog Comparator initialization
	// Analog Comparator: Off
	// The Analog Comparator's positive input is
	// connected to the AIN0 pin
	// The Analog Comparator's negative input is
	// connected to the AIN1 pin
	ACSR=(1<<ACD) | (0<<ACBG) | (0<<ACO) | (0<<ACI) | (0<<ACIE) | (0<<ACIC) | (0<<ACIS1) | (0<<ACIS0);
	// Digital input buffer on AIN0: On
	// Digital input buffer on AIN1: On
	DIDR=(0<<AIN0D) | (0<<AIN1D);


	// Globally enable interrupts
	#asm("sei")

	while (1)
  {
  	if (StrobPeriudFlag == 1)
  	{
  		RadioPriem();
  		StrobPeriudFlag = 0;
  	}
  	if (msLedB == 0)
    	PORTB.3 = 0; // Выключить LED B
  }
}
